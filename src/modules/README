Conventions for module interfacing:
===================================

* Initialization
  --------------

Each module must contain a class simply named `Module', deriving from the
class `rubber.Module'. The __init__ method takes the building environment as
its first argument and a dictionary as its second argument. This dictionary
describes the command that caused the module to be loaded, its keys are the
following:

  name = the macro's name (i.e. "usepackage" or "RequirePackage", or undefined
    if the module is loaded from the command line)
  arg = the module's name (i.e. the argument of the macro)
  opt = the module's options or None (either \usepackage's optional argument
    or the module options on the command line)

The __init__ function is supposed to register the macros supported by the
module using the following method of the environment:

  add_hook(name, fun)
    The function `fun' will be called when the macro of the given name is
    found. This function recieves as argument a dictionary that describes the
    macro call with the following keys:
      name = the name of the macro
      opt = the optional argument or None
      arg = the first argument (if it doesn't contains any brace) or None
      line = the rest of the line where the macro occurs


* Methods
  -------

The Module class may redefine the following methods:

  pre_compile (self)
    Called before the first compilation.

  post_compile (self)
    Called after each compilation. This function may additionally turn the
    variable `must_compile' (in the environment) to true to force a
    compilation in the next step.

  clean (self)
    Called when cleaning compilation results.

These have no effect in the base class.


* Available data
  --------------

The following member data of the environment may be of interest. They can be
modified with some care.

  output_processing
    A function called after the last compilation, or None.

  removed_files
    A list of additional files to be removed on cleaning.

  src_path = the pathname to the main source
  src_base = the base name of the main source
  src_pbase = the path and base name of the main source
  src_ext = the extension of the main source (e.g. ".tex")
  out_ext = the extension of the compiler's output file (e.g. ".dvi")

  depends = a dictionary that associates the names of the files needed for
    compilation with dependency nodes (from class Depend in rubber.util)


* Messages
  --------

During execution, all messages must be output using the method

  msg(verbosity_level, text)

of the environment passed to the __init__ method (technically, this is not a
method but a callable object).

The modules in the standard distribution import the symbol `_' from `rubber'
and output messages as `_("here I am")'. This is in preparation for the
upcoming internationalized version of Rubber.
